// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: summary.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkSummary = `-- name: CheckSummary :one
SELECT EXISTS (
  SELECT 1 FROM monthly_summary
  WHERE user_id = $1 AND year = $2 AND month = $3
)
`

type CheckSummaryParams struct {
	UserID int32
	Year   int32
	Month  int32
}

func (q *Queries) CheckSummary(ctx context.Context, arg CheckSummaryParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkSummary, arg.UserID, arg.Year, arg.Month)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getSummary = `-- name: GetSummary :one
select id, balance, total_income, total_expense, year, month
from monthly_summary
where user_id = $1 and year = $2 and month = $3
`

type GetSummaryParams struct {
	UserID int32
	Year   int32
	Month  int32
}

type GetSummaryRow struct {
	ID           string
	Balance      pgtype.Int4
	TotalIncome  int32
	TotalExpense int32
	Year         int32
	Month        int32
}

func (q *Queries) GetSummary(ctx context.Context, arg GetSummaryParams) (GetSummaryRow, error) {
	row := q.db.QueryRow(ctx, getSummary, arg.UserID, arg.Year, arg.Month)
	var i GetSummaryRow
	err := row.Scan(
		&i.ID,
		&i.Balance,
		&i.TotalIncome,
		&i.TotalExpense,
		&i.Year,
		&i.Month,
	)
	return i, err
}

const insertSummaryMonth = `-- name: InsertSummaryMonth :one
insert into monthly_summary(id, user_id, year, month, total_income, total_expense, created_at)
values ($1, $2, extract(year from $3::timestamptz)::int, extract(month from $3::timestamptz)::int, $4, $5, $3)
returning balance, total_income, total_expense, year, month
`

type InsertSummaryMonthParams struct {
	ID           string
	UserID       int32
	CreatedAt    pgtype.Timestamptz
	TotalIncome  int32
	TotalExpense int32
}

type InsertSummaryMonthRow struct {
	Balance      pgtype.Int4
	TotalIncome  int32
	TotalExpense int32
	Year         int32
	Month        int32
}

func (q *Queries) InsertSummaryMonth(ctx context.Context, arg InsertSummaryMonthParams) (InsertSummaryMonthRow, error) {
	row := q.db.QueryRow(ctx, insertSummaryMonth,
		arg.ID,
		arg.UserID,
		arg.CreatedAt,
		arg.TotalIncome,
		arg.TotalExpense,
	)
	var i InsertSummaryMonthRow
	err := row.Scan(
		&i.Balance,
		&i.TotalIncome,
		&i.TotalExpense,
		&i.Year,
		&i.Month,
	)
	return i, err
}

const updateTotalExpense = `-- name: UpdateTotalExpense :one
with expense_total as (
  select coalesce(sum(amount), 0) as total
  from expenses
  where user_id = $1
    and extract(year from created_at) = $2
    and extract(month from created_at) = $3
)
update monthly_summary
set total_expense = expense_total.total
from expense_total
where monthly_summary.user_id = $1
  and monthly_summary.year = $2
  and monthly_summary.month = $3
returning total_expense, balance, id
`

type UpdateTotalExpenseParams struct {
	UserID int32
	Year   int32
	Month  int32
}

type UpdateTotalExpenseRow struct {
	TotalExpense int32
	Balance      pgtype.Int4
	ID           string
}

func (q *Queries) UpdateTotalExpense(ctx context.Context, arg UpdateTotalExpenseParams) (UpdateTotalExpenseRow, error) {
	row := q.db.QueryRow(ctx, updateTotalExpense, arg.UserID, arg.Year, arg.Month)
	var i UpdateTotalExpenseRow
	err := row.Scan(&i.TotalExpense, &i.Balance, &i.ID)
	return i, err
}

const updateTotalIncome = `-- name: UpdateTotalIncome :one
with income_total as (
  select coalesce(sum(amount), 0) as total
  from incomes
  where user_id = $1
    and extract(year from created_at) = $2
    and extract(month from created_at) = $3
)
update monthly_summary
set total_income = income_total.total
from income_total
where monthly_summary.user_id = $1
  and monthly_summary.year = $2
  and monthly_summary.month = $3
returning total_income, balance, id
`

type UpdateTotalIncomeParams struct {
	UserID int32
	Year   int32
	Month  int32
}

type UpdateTotalIncomeRow struct {
	TotalIncome int32
	Balance     pgtype.Int4
	ID          string
}

func (q *Queries) UpdateTotalIncome(ctx context.Context, arg UpdateTotalIncomeParams) (UpdateTotalIncomeRow, error) {
	row := q.db.QueryRow(ctx, updateTotalIncome, arg.UserID, arg.Year, arg.Month)
	var i UpdateTotalIncomeRow
	err := row.Scan(&i.TotalIncome, &i.Balance, &i.ID)
	return i, err
}
